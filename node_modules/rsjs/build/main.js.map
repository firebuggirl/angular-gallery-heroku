{"version":3,"sources":["webpack:///webpack/bootstrap 775b2d5586bf92b92b29?8eef","webpack:///./RS.js?1154"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;ACtCA;;AAEA;;AAEA;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG,YAAY,WAAW;;AAE1B;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,SAAS;AACpB,aAAY,QAAQ;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAW,EAAE;AACb;AACA;AACA,QAAO,uCAAuC;AAC9C;;AAEA,UAAS,eAAe,EAAE;;AAE1B;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,EAAE;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,IAAG;AACH,UAAS,kCAAkC;AAC3C,cAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA,YAAW,EAAE;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,IAAG,YAAY,eAAe,SAAS;AACvC;AACA,UAAS,kCAAkC;AAC3C,gBAAe,sBAAsB;AACrC;AACA;;AAEA;AACA;AACA;AACA,YAAW,EAAE;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,IAAG,YAAY,eAAe,SAAS;AACvC;AACA,UAAS,kCAAkC;AAC3C,gBAAe,sBAAsB;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAuB,aAAa;;AAEpC,gBAAe;AACf,aAAY,mBAAmB;AAC/B;;AAEA;AACA;AACA,EAAC;;;AAGD;AACA,2CAA0C;;AAE1C;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA,EAAC;;AAED,qCAAoC;AACpC;AACA;AACA;AACA,EAAC,E","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 775b2d5586bf92b92b29\n **/","'use strict';\n\nmodule.exports = RS;\n\n/**\n * @class Reactive Stream.\n * @param {function} subscriber\n */\nfunction RS(subscriber) {\n  if (typeof subscriber !== 'function') throw TypeError\n    ('Subscriber is not a function: ' + subscriber);\n\n  this._subscriber = subscriber;\n}\n\n/**\n * Subscribe observer on stream.\n * @memberof RS#\n * @param {Object} observer\n * @return {Subscription}\n */\nfunction subscribe(observer) {\n  if (observer !== Object(observer)) throw TypeError\n    ('Observer is not an object: ' + observer);\n\n  var subscription = new Subscription, error, unsub,\n      control = new Control(observer, subscription);\n\n  try {\n    unsub = this._subscriber.call(undefined, control);\n  } catch (e) { error = e; }\n\n  if (unsub != null) {\n    if (typeof unsub.unsubscribe === 'function' ||\n        typeof unsub === 'function') {\n\n      if (subscription._unsub) {\n          subscription._unsub = unsub;\n      } else {\n          typeof unsub.unsubscribe === 'function' ?\n            unsub.unsubscribe() : unsub();\n      }\n\n    } else {\n      error = TypeError('Object has no method unsubscribe: ' + unsub);\n    }\n  }\n\n  if (error) control.error(error);\n\n  return subscription;\n}\n\n/**\n * Call fn(item) for each stream item.\n * @memberof RS#\n * @param {function} fn\n * @return {Promise} Resolve when stream complete.\n */\nfunction forEach(fn) {\n  var stream = this;\n\n  function forEachResolver(resolver, reject) {\n    if (typeof fn !== 'function') throw TypeError\n      ('Not a function: ' + fn);\n    var observer = {\n      fn: fn,\n      next: _forEachNext,\n      error: reject,\n      complete: resolver\n    };\n    observer.subscription = stream.subscribe(observer);\n  }\n\n  return new Promise(forEachResolver);\n}\n\n/**\n * Next action for method forEach.\n * @param {*} value\n */\nfunction _forEachNext(value) {\n  try { return this.fn.call(undefined, value); }\n  catch (e) {\n\n    try { this.error(e); } catch (e) {}\n\n    this.subscription.unsubscribe();\n  }\n}\n\n/**\n * @class Control\n * Control stream (SubscriptionObserver).\n * @param {Object} observer\n * @param {Subscription} subscription\n */\nfunction Control(observer, subscription) {\n  this._observer = observer;\n  this._subscription = subscription;\n}\n\n/**\n * Send next value to stream.\n * @memberof Control#\n * @param {*} value\n */\nfunction next(value) {\n  if (!this._subscription._unsub) return;\n\n  var next = this._observer.next;\n\n  try {\n    if (next != null && typeof next !== 'function')\n      throw TypeError('Object has no method next: ' + this._observer);\n\n    return next ? this._observer.next(value) : undefined;\n\n  } catch (e) {\n    try { this._subscription.unsubscribe(); }\n    finally { throw e; }\n  }\n}\n\n/**\n * Send error to stream.\n * @memberof Control#\n * @param {*} value\n */\nfunction error(value) {\n  if (!this._subscription._unsub) throw value;\n\n  var error = this._observer.error, thrown;\n\n  try {\n    if (error != null && typeof error !== 'function')\n      throw TypeError('Object has no method error: ' + this._observer);\n\n    if (error == null) throw value;\n\n    return this._observer.error(value);\n\n  } catch (e) { thrown = true; throw e; }\n  finally {\n    try { this._subscription.unsubscribe(); }\n    catch (e) { if (!thrown) throw e; }\n  }\n}\n\n/**\n * Send completion to stream.\n * @memberof Control#\n * @param {*} value\n */\nfunction complete(value) {\n  if (!this._subscription._unsub) return;\n\n  var complete = this._observer.complete, thrown;\n\n  try {\n    if (complete != null && typeof complete !== 'function')\n      throw TypeError('Object has no method complete: ' + this._observer);\n\n    return complete ? this._observer.complete(value) : undefined;\n\n  } catch (e) { thrown = true; throw e; }\n  finally {\n    try { this._subscription.unsubscribe(); }\n    catch (e) { if (!thrown) throw e; }\n  }\n}\n\n/**\n * @class Subscription\n * Connects a pair of stream-listener.\n */\nfunction Subscription() {\n  this._unsub = true;\n}\n\n/**\n * Unsubscribe from stream.\n * @memberof Subscription#\n */\nfunction unsubscribe() {\n  var unsub = this._unsub;\n\n  if (!unsub) return;\n\n  try {\n    if (unsub !== true) {\n      typeof unsub === 'function' ?\n        unsub() : unsub.unsubscribe();\n    }\n  } finally {\n    this._unsub = undefined;\n  }\n}\n\n/**\n * True, if already unsubscribed.\n * @memberof Subscription#\n * @return {boolean}\n */\nfunction isUnsubscribed() {\n  return !this._unsub;\n}\n\n/**\n * Define non-enumerable methods for prototype.\n * @param {Object} target\n * @param {Object} methods\n */\nfunction defineMethods(target, methods) {\n  for (var key in methods) {\n    desc.value = methods[key];\n    defineProperty(target, key, desc);\n  }\n}\n\nfunction returnThis() { return this; }\n\nvar symbol = {}, symDef = typeof Symbol === 'function',\n    desc = {configurable: true},\n    defineProperty = Object.defineProperty;\n\n['species', 'observable', 'iterator'].forEach(function(key) {\n  symbol[key] = (symDef && Symbol[key]) || '@@' + key;\n});\n\n\ndesc.get = isUnsubscribed;\ndefineProperty(Subscription.prototype = {}, 'isUnsubscribed', desc);\n\ndesc.get = returnThis;\ndefineProperty(RS, symbol.species, desc);\n\ndesc.writable = delete desc.get;\n\ndesc.value = returnThis;\ndefineProperty(RS.prototype, symbol.observable, desc);\n\ndefineMethods(RS.prototype, {\n  subscribe: subscribe,\n  forEach: forEach\n});\n\ndefineMethods(Subscription.prototype, {\n  unsubscribe: unsubscribe\n});\n\ndefineMethods(Control.prototype = {}, {\n  next: next,\n  error: error,\n  complete: complete\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./RS.js\n ** module id = 0\n ** module chunks = 0 1\n **/"],"sourceRoot":""}