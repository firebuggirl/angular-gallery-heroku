{"version":3,"sources":["webpack:///webpack/bootstrap 775b2d5586bf92b92b29","webpack:///./RS.js","webpack:///(webpack)/buildin/global.js","webpack:///(webpack)/buildin/module.js","webpack:////home/vohhov/JS/~/es-observable-tests/index.js","webpack:////home/vohhov/JS/~/zen-observable/index.js","webpack:///(webpack)/~/process/browser.js","webpack:///../test/test.js","webpack:////home/vohhov/JS/~/es-observable-tests/es-observable-tests.js","webpack:////home/vohhov/JS/~/zen-observable/zen-observable.js"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;ACtCA;;AAEA;;AAEA;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG,YAAY,WAAW;;AAE1B;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,SAAS;AACpB,aAAY,QAAQ;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAW,EAAE;AACb;AACA;AACA,QAAO,uCAAuC;AAC9C;;AAEA,UAAS,eAAe,EAAE;;AAE1B;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,EAAE;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,IAAG;AACH,UAAS,kCAAkC;AAC3C,cAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA,YAAW,EAAE;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,IAAG,YAAY,eAAe,SAAS;AACvC;AACA,UAAS,kCAAkC;AAC3C,gBAAe,sBAAsB;AACrC;AACA;;AAEA;AACA;AACA;AACA,YAAW,EAAE;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,IAAG,YAAY,eAAe,SAAS;AACvC;AACA,UAAS,kCAAkC;AAC3C,gBAAe,sBAAsB;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAuB,aAAa;;AAEpC,gBAAe;AACf,aAAY,mBAAmB;AAC/B;;AAEA;AACA;AACA,EAAC;;;AAGD;AACA,2CAA0C;;AAE1C;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA,EAAC;;AAED,qCAAoC;AACpC;AACA;AACA;AACA,EAAC,E;;;;;;AC/PD;;AAEA;AACA,kBAAiB,aAAa,EAAE;;AAEhC;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA4C;;AAE5C;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,iBAAiB;AACrC,IAAG;AACH;AACA;AACA;AACA,qBAAoB,iBAAiB;AACrC,IAAG;AACH;AACA;AACA;AACA;;;;;;;ACnBA;;;;;;;ACAA;;;;;;;ACAA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA2B;AAC3B;AACA;AACA;AACA,6BAA4B,UAAU;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","file":"test.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 775b2d5586bf92b92b29\n **/","'use strict';\n\nmodule.exports = RS;\n\n/**\n * @class Reactive Stream.\n * @param {function} subscriber\n */\nfunction RS(subscriber) {\n  if (typeof subscriber !== 'function') throw TypeError\n    ('Subscriber is not a function: ' + subscriber);\n\n  this._subscriber = subscriber;\n}\n\n/**\n * Subscribe observer on stream.\n * @memberof RS#\n * @param {Object} observer\n * @return {Subscription}\n */\nfunction subscribe(observer) {\n  if (observer !== Object(observer)) throw TypeError\n    ('Observer is not an object: ' + observer);\n\n  var subscription = new Subscription, error, unsub,\n      control = new Control(observer, subscription);\n\n  try {\n    unsub = this._subscriber.call(undefined, control);\n  } catch (e) { error = e; }\n\n  if (unsub != null) {\n    if (typeof unsub.unsubscribe === 'function' ||\n        typeof unsub === 'function') {\n\n      if (subscription._unsub) {\n          subscription._unsub = unsub;\n      } else {\n          typeof unsub.unsubscribe === 'function' ?\n            unsub.unsubscribe() : unsub();\n      }\n\n    } else {\n      error = TypeError('Object has no method unsubscribe: ' + unsub);\n    }\n  }\n\n  if (error) control.error(error);\n\n  return subscription;\n}\n\n/**\n * Call fn(item) for each stream item.\n * @memberof RS#\n * @param {function} fn\n * @return {Promise} Resolve when stream complete.\n */\nfunction forEach(fn) {\n  var stream = this;\n\n  function forEachResolver(resolver, reject) {\n    if (typeof fn !== 'function') throw TypeError\n      ('Not a function: ' + fn);\n    var observer = {\n      fn: fn,\n      next: _forEachNext,\n      error: reject,\n      complete: resolver\n    };\n    observer.subscription = stream.subscribe(observer);\n  }\n\n  return new Promise(forEachResolver);\n}\n\n/**\n * Next action for method forEach.\n * @param {*} value\n */\nfunction _forEachNext(value) {\n  try { return this.fn.call(undefined, value); }\n  catch (e) {\n\n    try { this.error(e); } catch (e) {}\n\n    this.subscription.unsubscribe();\n  }\n}\n\n/**\n * @class Control\n * Control stream (SubscriptionObserver).\n * @param {Object} observer\n * @param {Subscription} subscription\n */\nfunction Control(observer, subscription) {\n  this._observer = observer;\n  this._subscription = subscription;\n}\n\n/**\n * Send next value to stream.\n * @memberof Control#\n * @param {*} value\n */\nfunction next(value) {\n  if (!this._subscription._unsub) return;\n\n  var next = this._observer.next;\n\n  try {\n    if (next != null && typeof next !== 'function')\n      throw TypeError('Object has no method next: ' + this._observer);\n\n    return next ? this._observer.next(value) : undefined;\n\n  } catch (e) {\n    try { this._subscription.unsubscribe(); }\n    finally { throw e; }\n  }\n}\n\n/**\n * Send error to stream.\n * @memberof Control#\n * @param {*} value\n */\nfunction error(value) {\n  if (!this._subscription._unsub) throw value;\n\n  var error = this._observer.error, thrown;\n\n  try {\n    if (error != null && typeof error !== 'function')\n      throw TypeError('Object has no method error: ' + this._observer);\n\n    if (error == null) throw value;\n\n    return this._observer.error(value);\n\n  } catch (e) { thrown = true; throw e; }\n  finally {\n    try { this._subscription.unsubscribe(); }\n    catch (e) { if (!thrown) throw e; }\n  }\n}\n\n/**\n * Send completion to stream.\n * @memberof Control#\n * @param {*} value\n */\nfunction complete(value) {\n  if (!this._subscription._unsub) return;\n\n  var complete = this._observer.complete, thrown;\n\n  try {\n    if (complete != null && typeof complete !== 'function')\n      throw TypeError('Object has no method complete: ' + this._observer);\n\n    return complete ? this._observer.complete(value) : undefined;\n\n  } catch (e) { thrown = true; throw e; }\n  finally {\n    try { this._subscription.unsubscribe(); }\n    catch (e) { if (!thrown) throw e; }\n  }\n}\n\n/**\n * @class Subscription\n * Connects a pair of stream-listener.\n */\nfunction Subscription() {\n  this._unsub = true;\n}\n\n/**\n * Unsubscribe from stream.\n * @memberof Subscription#\n */\nfunction unsubscribe() {\n  var unsub = this._unsub;\n\n  if (!unsub) return;\n\n  try {\n    if (unsub !== true) {\n      typeof unsub === 'function' ?\n        unsub() : unsub.unsubscribe();\n    }\n  } finally {\n    this._unsub = undefined;\n  }\n}\n\n/**\n * True, if already unsubscribed.\n * @memberof Subscription#\n * @return {boolean}\n */\nfunction isUnsubscribed() {\n  return !this._unsub;\n}\n\n/**\n * Define non-enumerable methods for prototype.\n * @param {Object} target\n * @param {Object} methods\n */\nfunction defineMethods(target, methods) {\n  for (var key in methods) {\n    desc.value = methods[key];\n    defineProperty(target, key, desc);\n  }\n}\n\nfunction returnThis() { return this; }\n\nvar symbol = {}, symDef = typeof Symbol === 'function',\n    desc = {configurable: true},\n    defineProperty = Object.defineProperty;\n\n['species', 'observable', 'iterator'].forEach(function(key) {\n  symbol[key] = (symDef && Symbol[key]) || '@@' + key;\n});\n\n\ndesc.get = isUnsubscribed;\ndefineProperty(Subscription.prototype = {}, 'isUnsubscribed', desc);\n\ndesc.get = returnThis;\ndefineProperty(RS, symbol.species, desc);\n\ndesc.writable = delete desc.get;\n\ndesc.value = returnThis;\ndefineProperty(RS.prototype, symbol.observable, desc);\n\ndefineMethods(RS.prototype, {\n  subscribe: subscribe,\n  forEach: forEach\n});\n\ndefineMethods(Subscription.prototype, {\n  unsubscribe: unsubscribe\n});\n\ndefineMethods(Control.prototype = {}, {\n  next: next,\n  error: error,\n  complete: complete\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./RS.js\n ** module id = 0\n ** module chunks = 0 1\n **/","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() { return this; })();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/global.js\n ** module id = 1\n ** module chunks = 0\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: false,\r\n\t\t\tget: function() { return module.l; }\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tconfigurable: false,\r\n\t\t\tget: function() { return module.i; }\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 2\n ** module chunks = 0\n **/","module.exports = require(\"./es-observable-tests.js\");\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /home/vohhov/JS/~/es-observable-tests/index.js\n ** module id = 3\n ** module chunks = 0\n **/","module.exports = require(\"./zen-observable.js\").Observable;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /home/vohhov/JS/~/zen-observable/index.js\n ** module id = 4\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/process/browser.js\n ** module id = 5\n ** module chunks = 0\n **/","'use strict';\n\nvar observableTests = require(\"es-observable-tests\");\nwindow.zenObservable = require('zen-observable');\n\nvar RS = require('../src/RS');\n\nobservableTests.runTests(RS);\n\nmodule.exports = RS;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../test/test.js\n ** module id = 6\n ** module chunks = 0\n **/","/*=esdown=*/(function(fn, name) { if (typeof exports !== 'undefined') fn(exports, module); else if (typeof self !== 'undefined') fn(name === '*' ? self : (name ? self[name] = {} : {})); })(function(exports, module) { 'use strict'; var _esdown = {}; (function() { var exports = _esdown;\n\nvar VERSION = \"1.0.9\";\n\nvar GLOBAL = (function() {\n\n    try { return global.global } catch (x) {}\n    try { return self.self } catch (x) {}\n    return null;\n})();\n\nvar ownNames = Object.getOwnPropertyNames,\n      ownSymbols = Object.getOwnPropertySymbols,\n      getDesc = Object.getOwnPropertyDescriptor,\n      defineProp = Object.defineProperty;\n\nfunction toObject(val) {\n\n    if (val == null) // null or undefined\n        throw new TypeError(val + \" is not an object\");\n\n    return Object(val);\n}\n\n// Iterates over the descriptors for each own property of an object\nfunction forEachDesc(obj, fn) {\n\n    ownNames(obj).forEach(function(name) { return fn(name, getDesc(obj, name)); });\n    if (ownSymbols) ownSymbols(obj).forEach(function(name) { return fn(name, getDesc(obj, name)); });\n}\n\n// Installs a property into an object, merging \"get\" and \"set\" functions\nfunction mergeProp(target, name, desc, enumerable) {\n\n    if (desc.get || desc.set) {\n\n        var d$0 = { configurable: true };\n        if (desc.get) d$0.get = desc.get;\n        if (desc.set) d$0.set = desc.set;\n        desc = d$0;\n    }\n\n    desc.enumerable = enumerable;\n    defineProp(target, name, desc);\n}\n\n// Installs properties on an object, merging \"get\" and \"set\" functions\nfunction mergeProps(target, source, enumerable) {\n\n    forEachDesc(source, function(name, desc) { return mergeProp(target, name, desc, enumerable); });\n}\n\n// Builds a class\nfunction makeClass(def) {\n\n    var parent = Object.prototype,\n        proto = Object.create(parent),\n        statics = {};\n\n    def(function(obj) { return mergeProps(proto, obj, false); },\n        function(obj) { return mergeProps(statics, obj, false); });\n\n    var ctor = proto.constructor;\n    ctor.prototype = proto;\n\n    // Set class \"static\" methods\n    forEachDesc(statics, function(name, desc) { return defineProp(ctor, name, desc); });\n\n    return ctor;\n}\n\n// Support for computed property names\nfunction computed(target) {\n\n    for (var i$0 = 1; i$0 < arguments.length; i$0 += 3) {\n\n        var desc$0 = getDesc(arguments[i$0 + 1], \"_\");\n        mergeProp(target, arguments[i$0], desc$0, true);\n\n        if (i$0 + 2 < arguments.length)\n            mergeProps(target, arguments[i$0 + 2], true);\n    }\n\n    return target;\n}\n\n// Support for async functions\nfunction asyncFunction(iter) {\n\n    return new Promise(function(resolve, reject) {\n\n        resume(\"next\", void 0);\n\n        function resume(type, value) {\n\n            try {\n\n                var result$0 = iter[type](value);\n\n                if (result$0.done) {\n\n                    resolve(result$0.value);\n\n                } else {\n\n                    Promise.resolve(result$0.value).then(\n                        function(x) { return resume(\"next\", x); },\n                        function(x) { return resume(\"throw\", x); });\n                }\n\n            } catch (x) { reject(x) }\n        }\n    });\n}\n\n// Support for for-await\nfunction asyncIterator(obj) {\n\n    var method = obj[Symbol.asyncIterator] || obj[Symbol.iterator];\n    return method.call(obj);\n}\n\n// Support for async generators\nfunction asyncGenerator(iter) {\n\n    var front = null, back = null;\n\n    var aIter = {\n\n        next: function(val) { return send(\"next\", val) },\n        throw: function(val) { return send(\"throw\", val) },\n        return: function(val) { return send(\"return\", val) },\n    };\n\n    aIter[Symbol.asyncIterator] = function() { return this };\n    return aIter;\n\n    function send(type, value) {\n\n        return new Promise(function(resolve, reject) {\n\n            var x = { type: type, value: value, resolve: resolve, reject: reject, next: null };\n\n            if (back) {\n\n                // If list is not empty, then push onto the end\n                back = back.next = x;\n\n            } else {\n\n                // Create new list and resume generator\n                front = back = x;\n                resume(type, value);\n            }\n        });\n    }\n\n    function settle(type, value) {\n\n        switch (type) {\n\n            case \"return\":\n                front.resolve({ value: value, done: true });\n                break;\n\n            case \"throw\":\n                front.reject(value);\n                break;\n\n            default:\n                front.resolve({ value: value, done: false });\n                break;\n        }\n\n        front = front.next;\n\n        if (front) resume(front.type, front.value);\n        else back = null;\n    }\n\n    function resume(type, value) {\n\n        // HACK: If the generator does not support the \"return\" method, then\n        // emulate it (poorly) using throw.  (V8 circa 2015-02-13 does not support\n        // generator.return.)\n        if (type === \"return\" && !(type in iter)) {\n\n            type = \"throw\";\n            value = { value: value, __return: true };\n        }\n\n        try {\n\n            var result$1 = iter[type](value);\n            value = result$1.value;\n\n            if (value && typeof value === \"object\" && \"_esdown_await\" in value) {\n\n                if (result$1.done)\n                    throw new Error(\"Invalid async generator return\");\n\n                Promise.resolve(value._esdown_await).then(\n                    function(x) { return resume(\"next\", x); },\n                    function(x) { return resume(\"throw\", x); });\n\n            } else {\n\n                settle(result$1.done ? \"return\" : \"normal\", result$1.value);\n            }\n\n        } catch (x) {\n\n            // HACK: Return-as-throw\n            if (x && x.__return === true)\n                return settle(\"return\", x.value);\n\n            settle(\"throw\", x);\n        }\n    }\n}\n\n// Support for spread operations\nfunction spread(initial) {\n\n    return {\n\n        a: initial || [],\n\n        // Add items\n        s: function() {\n\n            for (var i$1 = 0; i$1 < arguments.length; ++i$1)\n                this.a.push(arguments[i$1]);\n\n            return this;\n        },\n\n        // Add the contents of iterables\n        i: function(list) {\n\n            if (Array.isArray(list)) {\n\n                this.a.push.apply(this.a, list);\n\n            } else {\n\n                for (var __$0 = (list)[Symbol.iterator](), __$1; __$1 = __$0.next(), !__$1.done;)\n                    { var item$0 = __$1.value; this.a.push(item$0); }\n            }\n\n            return this;\n        },\n\n    };\n}\n\n// Support for object destructuring\nfunction objd(obj) {\n\n    return toObject(obj);\n}\n\n// Support for array destructuring\nfunction arrayd(obj) {\n\n    if (Array.isArray(obj)) {\n\n        return {\n\n            at: function(skip, pos) { return obj[pos] },\n            rest: function(skip, pos) { return obj.slice(pos) },\n        };\n    }\n\n    var iter = toObject(obj)[Symbol.iterator]();\n\n    return {\n\n        at: function(skip) {\n\n            var r;\n\n            while (skip--)\n                r = iter.next();\n\n            return r.value;\n        },\n\n        rest: function(skip) {\n\n            var a = [], r;\n\n            while (--skip)\n                r = iter.next();\n\n            while (r = iter.next(), !r.done)\n                a.push(r.value);\n\n            return a;\n        },\n    };\n}\n\n\n\n\n\n\n\n\n\n\nexports.computed = computed;\nexports.spread = spread;\nexports.objd = objd;\nexports.arrayd = arrayd;\nexports.class = makeClass;\nexports.version = VERSION;\nexports.global = GLOBAL;\nexports.async = asyncFunction;\nexports.asyncGen = asyncGenerator;\nexports.asyncIter = asyncIterator;\n\n\n})();\n\nvar __M; (function(a) { var list = Array(a.length / 2); __M = function(i) { var m = list[i], f, e, ee; if (typeof m !== 'function') return m.exports; f = m; m = { exports: i ? {} : exports }; f(list[i] = m, e = m.exports); ee = m.exports; if (ee && ee !== e && !('default' in ee)) ee['default'] = ee; return ee; }; for (var i = 0; i < a.length; i += 2) { var j = Math.abs(a[i]); list[j] = a[i + 1]; if (a[i] >= 0) __M(j); } })([\n18, function(module, exports) {\n\nvar OP_toString = Object.prototype.toString,\n    OP_hasOwnProperty = Object.prototype.hasOwnProperty;\n\n// Returns the internal class of an object\nfunction getClass(o) {\n\n\tif (o === null || o === undefined) return \"Object\";\n\treturn OP_toString.call(o).slice(\"[object \".length, -1);\n}\n\n// Returns true if the argument is a Date object\nfunction isDate(obj) {\n\n    return getClass(obj) === \"Date\";\n}\n\n// Returns true if the argument is an object\nfunction isObject(obj) {\n\n    return obj && typeof obj === \"object\";\n}\n\n// ES6 Object.is\nfunction sameValue(left, right) {\n\n    if (left === right)\n        return left !== 0 || 1 / left === 1 / right;\n\n    return left !== left && right !== right;\n}\n\n// Returns true if the arguments are \"equal\"\nfunction equal(a, b) {\n\n    if (sameValue(a, b))\n        return true;\n\n\t// Dates must have equal time values\n\tif (isDate(a) && isDate(b))\n\t\treturn a.getTime() === b.getTime();\n\n\t// Non-objects must be strictly equal (types must be equal)\n\tif (!isObject(a) || !isObject(b))\n\t\treturn a === b;\n\n\t// Prototypes must be identical.  getPrototypeOf may throw on\n\t// ES3 engines that don't provide access to the prototype.\n\ttry {\n\n\t    if (Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\n\t\t    return false;\n\n\t} catch (err) {}\n\n\tvar aKeys = Object.keys(a),\n\t\tbKeys = Object.keys(b);\n\n\t// Number of own properties must be identical\n\tif (aKeys.length !== bKeys.length)\n\t\treturn false;\n\n\tfor (var i$0 = 0; i$0 < aKeys.length; ++i$0) {\n\n\t\t// Names of own properties must be identical\n\t\tif (!OP_hasOwnProperty.call(b, aKeys[i$0]))\n\t\t\treturn false;\n\n\t\t// Values of own properties must be equal\n\t\tif (!equal(a[aKeys[i$0]], b[aKeys[i$0]]))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvar Test = _esdown.class(function(__) { var Test;\n\n\t__({ constructor: Test = function(logger) {\n\n\t\tthis._name = \"\";\n\t\tthis._not = false;\n\t\tthis._logger = logger;\n\t},\n\n\t_: function(name) {\n\n\t    this._name = name;\n\t    return this;\n\t},\n\n\tname: function(name) {\n\n\t\tthis._name = name;\n\t\treturn this;\n\t},\n\n\tnot: function() {\n\n\t\tthis._not = !this._not;\n\t\treturn this;\n\t},\n\n\tassert: function(val) {\n\n\t\treturn this._assert(val, {\n\t\t\tmethod: \"assert\",\n            actual: val,\n            expected: true,\n\t\t});\n\t},\n\n\tequals: function(actual, expected) {\n\n\t\treturn this._assert(equal(actual, expected), {\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmethod: \"equal\"\n\t\t});\n\t},\n\n\tthrows: function(fn, error) {\n\n\t\tvar threw = false,\n            actual;\n\n\t\ttry { fn() }\n\t\tcatch (x) {\n            actual = x;\n            threw = (error === undefined || x === error || x instanceof error);\n        }\n\n\t\treturn this._assert(threw, {\n\t\t\tmethod: \"throws\",\n            actual: actual,\n            expected: error,\n\t\t});\n\t},\n\n\tcomment: function(msg) {\n\n\t    this._logger.comment(msg);\n\t},\n\n\t_assert: function(pred, data) {\n\n\t\tvar pass = !!pred,\n\t\t\tmethod = data.method || \"\";\n\n\t\tif (this._not) {\n\t\t\tpass = !pass;\n\t\t\tmethod = \"not \" + method;\n\t\t}\n\n\t\tvar obj = { name: this._name, pass: pass, method: method };\n\t\tObject.keys(data).forEach(function(k) { return obj[k] || (obj[k] = data[k]); });\n\n\t\tthis._logger.log(obj);\n\t\tthis._not = false;\n\n\t\treturn this;\n\t}});\n\n });\n\nexports.Test = Test;\n\n\n},\n16, function(module, exports) {\n\nvar ELEMENT_ID = \"moon-unit\";\n\nfunction findTarget() {\n\n    var e;\n\n    for (var w$0 = window; w$0; w$0 = w$0.parent) {\n\n        e = w$0.document.getElementById(ELEMENT_ID);\n\n        if (e)\n            return e;\n\n        if (w$0.parent === w$0)\n            break;\n    }\n\n    return null;\n}\n\nvar HtmlLogger = _esdown.class(function(__) { var HtmlLogger;\n\n    __({ constructor: HtmlLogger = function() {\n\n        this.target = findTarget();\n        this.clear();\n    },\n\n    clear: function() {\n\n        this.depth = 0;\n        this.passed = 0;\n        this.failed = 0;\n        this.html = \"\";\n\n        if (this.target)\n            this.target.innerHTML = \"\";\n    },\n\n    end: function() {\n\n        this._flush();\n    },\n\n    pushGroup: function(name) {\n\n        this.depth += 1;\n        this._writeHeader(name, this.depth);\n    },\n\n    popGroup: function() {\n\n        this.depth -= 1;\n        this._flush();\n    },\n\n    log: function(result) {\n\n        var passed = !!result.pass;\n\n        if (passed) this.passed++;\n        else this.failed++;\n\n        this.html +=\n        \"<div class='\" + (result.pass ? \"pass\" : \"fail\") + \"'>\\n\\\n            \" + (result.name) + \" <span class=\\\"status\\\">[\" + (passed ? \"OK\" : \"FAIL\") + \"]</span>\\n\\\n        </div>\";\n    },\n\n    comment: function(msg) {\n\n        this.html += \"<p class=\\\"comment\\\">\" + (msg) + \"</p>\";\n    },\n\n    error: function(e) {\n\n        if (e)\n            this.html += \"<p class=\\\"error\\\">\" + (e.stack) + \"</p>\";\n    },\n\n    _writeHeader: function(name) {\n\n        var level = Math.min(Math.max(2, this.depth + 1), 6);\n        this.html += \"<h\" + (level) + \">\" + (name) + \"</h\" + (level) + \">\";\n    },\n\n    _flush: function() {\n\n        if (!this.target)\n            return;\n\n        var document = this.target.ownerDocument,\n            div = document.createElement(\"div\"),\n            frag = document.createDocumentFragment(),\n            child;\n\n        div.innerHTML = this.html;\n        this.html = \"\";\n\n        while (child = div.firstChild)\n            frag.appendChild(child);\n\n        this.target.appendChild(frag);\n        div = null;\n    }});\n });\n\nexports.HtmlLogger = HtmlLogger;\n\n\n},\n17, function(module, exports) {\n\nvar Style = {\n\n    green: function(msg) { return \"\\x1B[32m\" + (msg) + \"\\x1B[39m\" },\n    red: function(msg) { return \"\\x1B[31m\" + (msg) + \"\\x1B[39m\" },\n    gray: function(msg) { return \"\\x1B[90m\" + (msg) + \"\\x1B[39m\" },\n    bold: function(msg) { return \"\\x1B[1m\" + (msg) + \"\\x1B[22m\" }\n}\n\nvar NodeLogger = _esdown.class(function(__) { var NodeLogger;\n\n    __({ constructor: NodeLogger = function() {\n\n        this.clear();\n    },\n\n    clear: function() {\n\n        this.passed = 0;\n        this.failed = 0;\n        this.failList = [];\n        this.path = [];\n        this.margin = false;\n    },\n\n    get indent() {\n\n        return new Array(Math.max(this.path.length, 0) * 2 + 1).join(\" \");\n    },\n\n    end: function() { var __this = this; \n\n        this.failList.forEach(function(__$0) { var __$1; var path = (__$1 = _esdown.objd(__$0), __$1.path), result = __$1.result; \n\n            if (result.name)\n                path += \" > \" + result.name;\n\n            __this._write(Style.bold(\"[\" + path + \"]\"));\n            __this._write(\"Actual: \" + result.actual);\n            __this._write(\"Expected: \" + result.expected);\n            __this._newline();\n        });\n    },\n\n    pushGroup: function(name) {\n\n        this._newline();\n        this._write(Style.bold(\"\" + (this.indent) + \"\" + (name) + \"\"));\n        this.path.push(name);\n    },\n\n    popGroup: function() {\n\n        this.path.pop();\n    },\n\n    log: function(result) {\n\n        var passed = !!result.pass;\n\n        if (passed) this.passed++;\n        else this.failed++;\n\n        if (!passed)\n            this.failList.push({ path: this.path.join(\" > \"), result: result });\n\n        this._write(\"\" + (this.indent) + \"\" + (result.name) + \" \" +\n            \"\" + (Style.bold(passed ? Style.green(\"OK\") : Style.red(\"FAIL\"))) + \"\");\n    },\n\n    error: function(e) {\n\n        if (e)\n            this._write(\"\\n\" + Style.red(e.stack) + \"\\n\");\n    },\n\n    comment: function(msg) {\n\n        this._newline();\n        this._write(this.indent + Style.gray(msg));\n        this._newline();\n    },\n\n    _write: function(text) {\n\n        console.log(text);\n        this.margin = false;\n    },\n\n    _newline: function() {\n\n        if (!this.margin)\n            console.log(\"\");\n\n        this.margin = true;\n    }});\n });\n\nexports.NodeLogger = NodeLogger;\n\n\n},\n15, function(module, exports) {\n\nvar HtmlLogger = __M(16).HtmlLogger;\nvar NodeLogger = __M(17).NodeLogger;\n\nvar Logger = (typeof global === \"object\" && global.process) ?\n    NodeLogger :\n    HtmlLogger;\n\nexports.Logger = Logger;\n\n\n},\n14, function(module, exports) {\n\nvar Test = __M(18).Test;\nvar Logger = __M(15).Logger;\n\nvar TestRunner = _esdown.class(function(__) { var TestRunner;\n\n    __({ constructor: TestRunner = function() {\n\n        this.logger = new Logger;\n        this.injections = {};\n    },\n\n    inject: function(obj) { var __this = this; \n\n        Object.keys(obj || {}).forEach(function(k) { return __this.injections[k] = obj[k]; });\n        return this;\n    },\n\n    run: function(tests) { var __this = this; \n\n        this.logger.clear();\n        this.logger.comment(\"Starting tests...\");\n\n        return this._visit(tests).then(function(val) {\n\n            __this.logger.comment(\"Passed \" + (__this.logger.passed) + \" tests and failed \" + (__this.logger.failed) + \" tests.\");\n            __this.logger.end();\n            return __this;\n        });\n    },\n\n    _exec: function(fn) { var __this = this; \n\n        return new Promise(function(resolve) {\n\n            resolve(fn(new Test(__this.logger), __this.injections));\n\n        }).catch(function(error) {\n\n            __this.logger.error(error);\n            throw error;\n        });\n    },\n\n    _visit: function(node) { var __this = this; \n\n        return new Promise(function(resolve) {\n\n            var list = Object.keys(node);\n\n            var next = function($) {\n\n                if (list.length === 0)\n                    return;\n\n                var k = list.shift();\n\n                __this.logger.pushGroup(k);\n\n                var p = typeof node[k] === \"function\" ?\n                    __this._exec(node[k]) :\n                    __this._visit(node[k]);\n\n                return p.then(function($) { return __this.logger.popGroup(); }).then(next);\n            };\n\n            resolve(next());\n        });\n    }});\n });\n\nexports.TestRunner = TestRunner;\n\n\n},\n12, function(module, exports) {\n\nvar TestRunner = __M(14).TestRunner;\nvar Logger = __M(15).Logger;\n\nfunction runTests(tests) {\n\n    return new TestRunner().run(tests);\n}\n\n\n\nexports.runTests = runTests;\nexports.TestRunner = TestRunner;\n\n\n},\n1, function(module, exports) {\n\nObject.keys(__M(12)).forEach(function(k) { exports[k] = __M(12)[k]; });\n\n\n},\n13, function(module, exports) {\n\nfunction testLength(test, value, length) {\n\n    if (typeof value !== \"function\" || typeof length !== \"number\")\n        return;\n\n    test._(\"Function length is \" + length)\n    .equals(value.length, length);\n}\n\nfunction testMethodProperty(test, object, key, options) {\n\n    var desc = Object.getOwnPropertyDescriptor(object, key);\n\n    if (options.get || options.set) {\n\n        test._(\"Property \" + (options.get ? \"has\" : \"does not have\") + \" a getter\")\n        .equals(typeof desc.get, options.get ? \"function\" : \"undefined\");\n\n        testLength(test, desc.get, 0);\n\n        test._(\"Property \" + (options.set ? \"has\" : \"does not have\") + \" a setter\")\n        .equals(typeof desc.set, options.set ? \"function\" : \"undefined\");\n\n        testLength(test, desc.set, 1);\n\n    } else {\n\n        test._(\"Property has a function value\")\n        .equals(typeof desc.value, \"function\");\n\n        testLength(test, desc.value, options.length);\n\n        test._(\"Property is \" + (options.writable ? \"\" : \"non-\") + \"writable\")\n        .equals(desc.writable, Boolean(options.writable));\n    }\n\n\n    test\n    ._(\"Property is \" + (options.enumerable ? \"\" : \"non-\") + \"enumerable\")\n    .equals(desc.enumerable, Boolean(options.enumerable))\n    ._(\"Property is \" + (options.configurable ? \"\" : \"non-\") + \"configurable\")\n    .equals(desc.configurable, Boolean(options.configurable))\n    ;\n\n}\n\nfunction hasSymbol(name) {\n\n    return typeof Symbol === \"function\" && Boolean(Symbol[name]);\n}\n\nfunction getSymbol(name) {\n\n    return hasSymbol(name) ? Symbol[name] : \"@@\" + name;\n}\n\nexports.testMethodProperty = testMethodProperty;\nexports.hasSymbol = hasSymbol;\nexports.getSymbol = getSymbol;\n\n\n},\n2, function(module, exports) {\n\nvar testMethodProperty = __M(13).testMethodProperty;\n\nexports[\"default\"] = {\n\n    \"Argument types\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        test\n        ._(\"The first argument cannot be a non-callable object\")\n        .throws(function(_) { return new Observable({}); }, TypeError)\n        ._(\"The first argument cannot be a primative value\")\n        .throws(function(_) { return new Observable(false); }, TypeError)\n        .throws(function(_) { return new Observable(null); }, TypeError)\n        .throws(function(_) { return new Observable(undefined); }, TypeError)\n        .throws(function(_) { return new Observable(1); }, TypeError)\n        ._(\"The first argument can be a function\")\n        .not().throws(function(_) { return new Observable(function() {}); })\n        ;\n    },\n\n    \"Observable.prototype has a constructor property\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        testMethodProperty(test, Observable.prototype, \"constructor\", {\n            configurable: true,\n            writable: true,\n            length: 1,\n        });\n\n        test._(\"Observable.prototype.constructor === Observable\")\n        .equals(Observable.prototype.constructor, Observable);\n    },\n\n    \"Subscriber function is not called by constructor\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var called = 0;\n        new Observable(function(_) { return called++; });\n\n        test\n        ._(\"The constructor does not call the subscriber function\")\n        .equals(called, 0)\n        ;\n    },\n\n};\n\n\n},\n3, function(module, exports) {\n\nvar testMethodProperty = __M(13).testMethodProperty;\n\nexports[\"default\"] = {\n\n    \"Observable.prototype has a subscribe property\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        testMethodProperty(test, Observable.prototype, \"subscribe\", {\n            configurable: true,\n            writable: true,\n            length: 1,\n        });\n    },\n\n    \"Argument type\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var x = new Observable(function(sink) { return null; });\n\n        test\n        ._(\"Throws if observer is not an object\")\n        .throws(function(_) { return x.subscribe(null); }, TypeError)\n        .throws(function(_) { return x.subscribe(undefined); }, TypeError)\n        .throws(function(_) { return x.subscribe(1); }, TypeError)\n        .throws(function(_) { return x.subscribe(true); }, TypeError)\n        .throws(function(_) { return x.subscribe(\"string\"); }, TypeError)\n\n        ._(\"Any object may be an observer\")\n        .not().throws(function(_) { return x.subscribe({}); })\n        .not().throws(function(_) { return x.subscribe(Object(1)); })\n        .not().throws(function(_) { return x.subscribe(function() {}); })\n        ;\n    },\n\n    \"Subscriber arguments\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var observer = null;\n        new Observable(function(x) { observer = x }).subscribe({});\n\n        test._(\"Subscriber is called with an observer\")\n        .equals(typeof observer, \"object\")\n        .equals(typeof observer.next, \"function\")\n        .equals(typeof observer.error, \"function\")\n        .equals(typeof observer.complete, \"function\")\n        ;\n\n        test._(\"Subscription observer's constructor property is Object\")\n        .equals(observer.constructor, Object);\n    },\n\n    \"Subscriber return types\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var type = \"\", sink = {};\n\n        test\n        ._(\"Undefined can be returned\")\n        .not().throws(function(_) { return new Observable(function(sink) { return undefined; }).subscribe(sink); })\n        ._(\"Null can be returned\")\n        .not().throws(function(_) { return new Observable(function(sink) { return null; }).subscribe(sink); })\n        ._(\"Functions can be returned\")\n        .not().throws(function(_) { return new Observable(function(sink) { return function() {}; }).subscribe(sink); })\n        ._(\"Subscriptions can be returned\")\n        .not().throws(function(_) { return new Observable(function(sink) { return ({ unsubscribe: function() {} }).subscribe(sink); }); })\n        ._(\"Non callable, non-subscription objects cannot be returned\")\n        .throws(function(_) { return new Observable(function(sink) { return ({}); }).subscribe(sink); }, TypeError)\n        ._(\"Non-functions cannot be returned\")\n        .throws(function(_) { return new Observable(function(sink) { return 0; }).subscribe(sink); }, TypeError)\n        .throws(function(_) { return new Observable(function(sink) { return false; }).subscribe(sink); }, TypeError)\n        ;\n    },\n\n    \"Returns a subscription object\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var called = 0;\n        var subscription = new Observable(function(observer) {\n            return function(_) { return called++; };\n        }).subscribe({});\n\n        var proto = Object.getPrototypeOf(subscription);\n\n        test\n        ._(\"Subscribe returns an object\")\n        .equals(typeof subscription, \"object\")\n        ._(\"Subscriptions have an unsubscribe method\")\n        .equals(typeof subscription.unsubscribe, \"function\")\n        ._(\"Contructor property is Object\")\n        .equals(subscription.constructor, Object)\n        ._(\"Unsubscribe is defined on the prototype object\")\n        .equals(subscription.unsubscribe, proto.unsubscribe)\n        ._(\"Unsubscribe returns undefined\")\n        .equals(subscription.unsubscribe(), undefined)\n        ._(\"Unsubscribe calls the cleanup function\")\n        .equals(called, 1)\n        ;\n    },\n\n    \"Cleanup function\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var called = 0,\n            returned = 0;\n\n        var subscription = new Observable(function(sink) {\n            return function(_) { called++ };\n        }).subscribe({\n            complete: function() { returned++ },\n        });\n\n        subscription.unsubscribe();\n\n        test._(\"The cleanup function is called when unsubscribing\")\n        .equals(called, 1);\n\n        subscription.unsubscribe();\n\n        test._(\"The cleanup function is not called again when unsubscribe is called again\")\n        .equals(called, 1);\n\n        called = 0;\n\n        new Observable(function(sink) {\n            sink.error(1);\n            return function(_) { called++ };\n        }).subscribe({\n            error: function() {},\n        });\n\n        test._(\"The cleanup function is called when an error is sent to the sink\")\n        .equals(called, 1);\n\n        called = 0;\n\n        new Observable(function(sink) {\n            sink.complete(1);\n            return function(_) { called++ };\n        }).subscribe({\n            next: function() {},\n        });\n\n        test._(\"The cleanup function is called when a complete is sent to the sink\")\n        .equals(called, 1);\n\n        var unsubscribeArgs = null;\n        called = 0;\n\n        subscription = new Observable(function(sink) {\n            return {\n                unsubscribe: function() { for (var args = [], __$0 = 0; __$0 < arguments.length; ++__$0) args.push(arguments[__$0]); \n                    called = 1;\n                    unsubscribeArgs = args;\n                }\n            };\n        }).subscribe({\n            next: function() {},\n        });\n\n        subscription.unsubscribe(1);\n        test._(\"If a subscription is returned, then unsubscribe is called on cleanup\")\n        .equals(called, 1)\n        ._(\"Arguments are not forwarded to the unsubscribe function\")\n        .equals(unsubscribeArgs, []);\n\n    },\n\n    \"Exceptions thrown from the subscriber\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var error = new Error(),\n            observable = new Observable(function(_) { throw error });\n\n        test._(\"Subscribe throws if the observer does not handle errors\")\n        .throws(function(_) { return observable.subscribe({}); }, error);\n\n        var thrown = null;\n        observable.subscribe({ error: function(e) { thrown = e } });\n\n        test._(\"Subscribe sends an error to the observer\")\n        .equals(thrown, error);\n    },\n\n};\n\n\n},\n4, function(module, exports) {\n\nvar testMethodProperty = __M(13).testMethodProperty;\n\nexports[\"default\"] = {\n\n    \"Observable.prototype has a forEach property\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        testMethodProperty(test, Observable.prototype, \"forEach\", {\n            configurable: true,\n            writable: true,\n            length: 1,\n        });\n    },\n\n    \"Argument must be a function\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var result = Observable.prototype.forEach.call({}, {});\n\n        test._(\"If the first argument is not a function, a promise is returned\")\n        .assert(result instanceof Promise);\n\n        return result.then(function(_) { return null; }, function(e) { return e; }).then(function(error) {\n\n            test._(\"The promise is rejected with a TypeError\")\n            .assert(Boolean(error))\n            .assert(error instanceof TypeError);\n        });\n    },\n\n    \"Subscribe is called on the 'this' value\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var called = 0,\n            observer = null;\n\n        Observable.prototype.forEach.call({\n\n            subscribe: function(x) {\n                called++;\n                observer = x;\n            }\n\n        }, function(_) { return null; });\n\n        test._(\"The subscribe method is called with an observer\")\n        .equals(called, 1)\n        .equals(typeof observer, \"object\")\n        .equals(typeof observer.next, \"function\")\n        ;\n    },\n\n    \"Error rejects the promise\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var error = new Error();\n\n        return new Observable(function(observer) { observer.error(error) })\n            .forEach(function(_) { return null; })\n            .then(function(_) { return null; }, function(e) { return e; })\n            .then(function(value) {\n                test._(\"Sending error rejects the promise with the supplied value\")\n                .equals(value, error);\n            });\n    },\n\n    \"Complete resolves the promise\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var token = {};\n\n        return new Observable(function(observer) { observer.complete(token) })\n            .forEach(function(_) { return null; })\n            .then(function(x) { return x; }, function(e) { return null; })\n            .then(function(value) {\n                test._(\"Sending complete resolves the promise with the supplied value\")\n                .equals(value, token);\n            });\n    },\n\n    \"The callback is called with the next value\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var values = [], thisArg;\n\n        return new Observable(function(observer) {\n\n            observer.next(1);\n            observer.next(2);\n            observer.next(3);\n            observer.complete();\n\n        }).forEach(function(x) {\n\n            thisArg = this;\n            values.push(x);\n\n        }).then(function(_) {\n\n            test\n            ._(\"The callback receives each next value\")\n            .equals(values, [1, 2, 3])\n            ._(\"The callback receives undefined as the this value\")\n            .equals(thisArg, undefined);\n\n        });\n    },\n\n    \"If the callback throws an error, the promise is rejected\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var error = new Error();\n\n        return new Observable(function(observer) { observer.next(1) })\n            .forEach(function(_) { throw error })\n            .then(function(_) { return null; }, function(e) { return e; })\n            .then(function(value) {\n                test._(\"The promise is rejected with the thrown value\")\n                .equals(value, error);\n            });\n    },\n\n    \"If the callback throws an error, the callback function is not called again\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var callCount = 0;\n\n        return new Observable(function(observer) {\n            observer.next(1);\n            observer.next(2);\n            observer.next(3);\n        }).forEach(function(x) {\n            callCount++;\n            throw new Error();\n        }).catch(function(x) {\n            test._(\"The callback is not called again after throwing an error\")\n            .equals(callCount, 1);\n        });\n    },\n\n};\n\n\n},\n5, function(module, exports) {\n\nvar testMethodProperty = __M(13).testMethodProperty, getSymbol = __M(13).getSymbol;\n\nexports[\"default\"] = {\n\n    \"Observable.prototype has a Symbol.observable method\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        testMethodProperty(test, Observable.prototype, getSymbol(\"observable\"), {\n            configurable: true,\n            writable: true,\n            length: 0\n        });\n    },\n\n    \"Return value\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var desc = Object.getOwnPropertyDescriptor(Observable.prototype, getSymbol(\"observable\")),\n            thisVal = {};\n\n        test._(\"Returns the 'this' value\").equals(desc.value.call(thisVal), thisVal);\n    }\n\n};\n\n\n},\n6, function(module, exports) {\n\nvar testMethodProperty = __M(13).testMethodProperty, getSymbol = __M(13).getSymbol;\n\nexports[\"default\"] = {\n\n    \"Observable has a species method\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        testMethodProperty(test, Observable, getSymbol(\"species\"), {\n            get: true,\n            configurable: true\n        });\n    },\n\n    \"Return value\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var desc = Object.getOwnPropertyDescriptor(Observable, getSymbol(\"species\")),\n            thisVal = {};\n\n        test._(\"Returns the 'this' value\").equals(desc.get.call(thisVal), thisVal);\n    }\n\n};\n\n\n},\n7, function(module, exports) {\n\nvar testMethodProperty = __M(13).testMethodProperty;\n\n// TODO: Verify that Observable.from subscriber returns a cleanup function\n\nexports[\"default\"] = {\n\n    \"Observable has an of property\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        testMethodProperty(test, Observable, \"of\", {\n            configurable: true,\n            writable: true,\n            length: 0,\n        });\n    },\n\n    \"Uses the this value if it's a function\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var usesThis = false;\n\n        Observable.of.call(function(_) { return usesThis = true; });\n        test._(\"Observable.of will use the 'this' value if it is callable\")\n        .equals(usesThis, true);\n    },\n\n    \"Uses 'Observable' if the 'this' value is not a function\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var result = Observable.of.call({}, 1, 2, 3, 4);\n\n        test._(\"Observable.of will use 'Observable' if the this value is not callable\")\n        .assert(result instanceof Observable);\n    },\n\n    \"Arguments are delivered to next\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        return new Promise(function(resolve) {\n\n            var values = [],\n                turns = 0;\n\n            Observable.of(1, 2, 3, 4).subscribe({\n\n                next: function(v) {\n                    values.push(v);\n                    Promise.resolve().then(function(_) { return turns++; });\n                },\n\n                complete: function() {\n                    test._(\"All items are delivered and complete is called\")\n                    .equals(values, [1, 2, 3, 4]);\n                    test._(\"Items are delivered in a single future turn\")\n                    .equals(turns, 1);\n\n                    resolve();\n                },\n            });\n\n            turns++;\n\n        });\n    },\n\n    \"Responds to cancellation from next\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        return new Promise(function(resolve) {\n\n            var values = [];\n\n            var subscription = Observable.of(1, 2, 3, 4).subscribe({\n\n                next: function(v) {\n\n                    values.push(v);\n                    subscription.unsubscribe();\n                    Promise.resolve().then(function(_) {\n                        test._(\"Cancelling from next stops observation\")\n                        .equals(values, [1]);\n                        resolve();\n                    });\n                }\n            });\n        });\n    },\n\n    \"Responds to cancellation before next is called\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        return new Promise(function(resolve) {\n\n            var values = [];\n\n            var subscription = Observable.of(1, 2, 3, 4).subscribe({\n                next: function(v) { values.push(v) }\n            });\n\n            subscription.unsubscribe();\n\n            Promise.resolve().then(function(_) {\n                test._(\"Cancelling before next is called stops observation\")\n                .equals(values, []);\n                resolve();\n            });\n        });\n    },\n\n};\n\n\n},\n8, function(module, exports) {\n\nvar testMethodProperty = __M(13).testMethodProperty, hasSymbol = __M(13).hasSymbol, getSymbol = __M(13).getSymbol;\n\n// TODO: Verify that Observable.from subscriber returns a cleanup function\n\nexports[\"default\"] = {\n\n    \"Observable has a from property\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        testMethodProperty(test, Observable, \"from\", {\n            configurable: true,\n            writable: true,\n            length: 1\n        });\n    },\n\n    \"Allowed argument types\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        test\n        ._(\"Null is not allowed\")\n        .throws(function(_) { return Observable.from(null); }, TypeError)\n        ._(\"Undefined is not allowed\")\n        .throws(function(_) { return Observable.from(undefined); }, TypeError)\n        .throws(function(_) { return Observable.from(); }, TypeError);\n    },\n\n    \"Uses the this value if it's a function\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var usesThis = false;\n\n        Observable.from.call(function(_) { return usesThis = true; }, []);\n        test._(\"Observable.from will use the 'this' value if it is callable\")\n        .equals(usesThis, true);\n    },\n\n    \"Uses 'Observable' if the 'this' value is not a function\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var result = Observable.from.call({}, []);\n\n        test._(\"Observable.from will use 'Observable' if the this value is not callable\")\n        .assert(result instanceof Observable);\n    },\n\n    \"Symbol.observable method is accessed\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var called = 0;\n\n        Observable.from(_esdown.computed({\n            }, getSymbol(\"observable\"), { get _() {\n                called++;\n                return function(_) { return ({}); };\n            }\n        }));\n\n        test._(\"Symbol.observable property is accessed once\")\n        .equals(called, 1);\n\n        test\n        ._(\"Symbol.observable must be a function\")\n        .throws(function(_) { return Observable.from(_esdown.computed({ }, getSymbol(\"observable\"), { _: {} })); }, TypeError)\n        .throws(function(_) { return Observable.from(_esdown.computed({ }, getSymbol(\"observable\"), { _: 0 })); }, TypeError)\n        ._(\"Null is allowed\")\n        .not().throws(function(_) { return Observable.from(_esdown.computed({ }, getSymbol(\"observable\"), { _: null })); })\n        ._(\"Undefined is allowed\")\n        .not().throws(function(_) { return Observable.from(_esdown.computed({ }, getSymbol(\"observable\"), { _: undefined })); })\n        ;\n\n        called = 0;\n        Observable.from(_esdown.computed({\n            }, getSymbol(\"observable\"), { _: function() {\n                called++;\n                return {};\n            }\n        }));\n\n        test._(\"Calls the Symbol.observable method\")\n        .equals(called, 1);\n    },\n\n    \"Return value of Symbol.observable\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        test._(\"Throws if the return value of Symbol.observable is not an object\")\n        .throws(function(_) { return Observable.from(_esdown.computed({ }, getSymbol(\"observable\"), { _: function() { return 0 } })); }, TypeError)\n        .throws(function(_) { return Observable.from(_esdown.computed({ }, getSymbol(\"observable\"), { _: function() { return null } })); }, TypeError)\n        .throws(function(_) { return Observable.from(_esdown.computed({ }, getSymbol(\"observable\"), { _: function() {} })); }, TypeError)\n        .not().throws(function(_) { return Observable.from(_esdown.computed({ }, getSymbol(\"observable\"), { _: function() { return {} } })); })\n        .not().throws(function(_) { return Observable.from(_esdown.computed({ }, getSymbol(\"observable\"), { _: function() { return function(_) {} } })); })\n        ;\n\n        var target = function() {},\n            returnValue = { constructor: target };\n\n        var result = Observable.from.call(target, _esdown.computed({\n            }, getSymbol(\"observable\"), { _: function() { return returnValue }\n        }));\n\n        test._(\"Returns the result of Symbol.observable if the object's constructor property \" +\n            \"is the target\")\n        .equals(result, returnValue);\n\n        var input = null,\n            token = {};\n\n        target = function(fn) {\n            this.fn = fn;\n            this.token = token;\n        };\n\n        result = Observable.from.call(target, _esdown.computed({\n            }, getSymbol(\"observable\"), { _: function() {\n                return {\n                    subscribe: function(x) {\n                        input = x;\n                        return token;\n                    },\n                };\n            }\n        }));\n\n        test._(\"Calls the constructor if returned object does not have matching constructor \" +\n            \"property\")\n        .equals(result.token, token)\n        ._(\"Constructor is called with a function\")\n        .equals(typeof result.fn, \"function\")\n        ._(\"Calling the function calls subscribe on the object and returns the result\")\n        .equals(result.fn(123), token)\n        ._(\"The subscriber argument is supplied to the subscribe method\")\n        .equals(input, 123)\n        ;\n\n    },\n\n    \"Iterables: values are delivered to next\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        return new Promise(function(resolve) {\n\n            var values = [],\n                turns = 0,\n                iterable = [1, 2, 3, 4];\n\n            if (hasSymbol(\"iterator\"))\n                iterable = iterable[Symbol.iterator]();\n\n            Observable.from(iterable).subscribe({\n\n                next: function(v) {\n                    values.push(v);\n                    Promise.resolve().then(function(_) { return turns++; });\n                },\n\n                complete: function() {\n                    test._(\"All items are delivered and complete is called\")\n                    .equals(values, [1, 2, 3, 4]);\n                    test._(\"Items are delivered in a single future turn\")\n                    .equals(turns, 1);\n\n                    resolve();\n                },\n            });\n\n            turns++;\n\n        });\n    },\n\n    \"Iterables: responds to cancellation from next\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        return new Promise(function(resolve) {\n\n            var values = [];\n\n            var subscription = Observable.from([1, 2, 3, 4]).subscribe({\n\n                next: function(v) {\n\n                    values.push(v);\n                    subscription.unsubscribe();\n                    Promise.resolve().then(function(_) {\n                        test._(\"Cancelling from next stops observation\")\n                        .equals(values, [1]);\n                        resolve();\n                    });\n                }\n            });\n        });\n    },\n\n    \"Iterables: responds to cancellation before next is called\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        return new Promise(function(resolve) {\n\n            var values = [];\n\n            var subscription = Observable.from([1, 2, 3, 4]).subscribe({\n                next: function(v) { values.push(v) }\n            });\n\n            subscription.unsubscribe();\n\n            Promise.resolve().then(function(_) {\n                test._(\"Cancelling before next is called stops observation\")\n                .equals(values, []);\n                resolve();\n            });\n        });\n    },\n\n    \"Non-iterables result in a catchable error\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var error = null;\n        Observable.from({}).subscribe({ error: function(e) { error = e } });\n\n        return new Promise(function(resolve) {\n\n            setTimeout(function(_) {\n\n                test._(\"If argument is not iterable, then error method is called\")\n                .assert(error instanceof Error);\n\n                resolve();\n\n            }, 10);\n        });\n\n    },\n\n};\n\n\n},\n9, function(module, exports) {\n\nvar testMethodProperty = __M(13).testMethodProperty;\n\nexports[\"default\"] = {\n\n    \"SubscriptionObserver.prototype has an next method\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var observer;\n        new Observable(function(x) { observer = x }).subscribe({});\n\n        testMethodProperty(test, Object.getPrototypeOf(observer), \"next\", {\n            configurable: true,\n            writable: true,\n            length: 1\n        });\n    },\n\n    \"Input value\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var token = {};\n\n        new Observable(function(observer) {\n\n            observer.next(token);\n\n        }).subscribe({\n\n            next: function(value) { for (var args = [], __$0 = 1; __$0 < arguments.length; ++__$0) args.push(arguments[__$0]); \n                test._(\"Input value is forwarded to the observer\")\n                .equals(value, token);\n            }\n\n        });\n    },\n\n    \"Return value\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var token = {};\n\n        new Observable(function(observer) {\n\n            test._(\"Returns the value returned from the observer\")\n            .equals(observer.next(), token);\n\n            observer.complete();\n\n            test._(\"Returns undefined when closed\")\n            .equals(observer.next(), undefined);\n\n        }).subscribe({\n            next: function() { return token }\n        });\n    },\n\n    \"Method lookup\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var observer,\n            observable = new Observable(function(x) { observer = x });\n\n        observable.subscribe({});\n        test._(\"If property does not exist, then next returns undefined\")\n        .equals(observer.next(), undefined);\n\n        observable.subscribe({ next: undefined });\n        test._(\"If property is undefined, then next returns undefined\")\n        .equals(observer.next(), undefined);\n\n        observable.subscribe({ next: null });\n        test._(\"If property is null, then next returns undefined\")\n        .equals(observer.next(), undefined);\n\n        observable.subscribe({ next: {} });\n        test._(\"If property is not a function, then an error is thrown\")\n        .throws(function(_) { return observer.next(); }, TypeError);\n\n        var actual = {};\n        observable.subscribe(actual);\n        actual.next = (function(_) { return 1; });\n        test._(\"Method is not accessed until complete is called\")\n        .equals(observer.next(), 1);\n\n        var called = 0;\n        observable.subscribe({\n            get next() {\n                called++;\n                return function() {};\n            }\n        });\n        observer.complete();\n        observer.next();\n        test._(\"Method is not accessed when subscription is closed\")\n        .equals(called, 0);\n\n        called = 0;\n        observable.subscribe({\n            get next() {\n                called++;\n                return function() {};\n            }\n        });\n        observer.next();\n        test._(\"Property is only accessed once during a lookup\")\n        .equals(called, 1);\n\n    },\n\n    \"Cleanup functions\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var called, observer;\n\n        var observable = new Observable(function(x) {\n            observer = x;\n            return function(_) { called++ };\n        });\n\n        called = 0;\n        observable.subscribe({ next: function() { throw new Error() } });\n        try { observer.next() }\n        catch (x) {}\n        test._(\"Cleanup function is called when next throws an error\")\n        .equals(called, 1);\n\n        var error = new Error(), caught = null;\n\n        new Observable(function(x) {\n            observer = x;\n            return function(_) { throw new Error() };\n        }).subscribe({ next: function() { throw error } });\n\n        try { observer.next() }\n        catch (x) { caught = x }\n\n        test._(\"If both next and the cleanup function throw, then the error \" +\n            \"from the next method is thrown\")\n        .assert(caught === error);\n\n    },\n\n};\n\n\n},\n10, function(module, exports) {\n\nvar testMethodProperty = __M(13).testMethodProperty;\n\nexports[\"default\"] = {\n\n    \"SubscriptionObserver.prototype has an error method\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var observer;\n        new Observable(function(x) { observer = x }).subscribe({});\n\n        testMethodProperty(test, Object.getPrototypeOf(observer), \"error\", {\n            configurable: true,\n            writable: true,\n            length: 1\n        });\n    },\n\n    \"Input value\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var token = {};\n\n        new Observable(function(observer) {\n\n            observer.error(token, 1, 2);\n\n        }).subscribe({\n\n            error: function(value) { for (var args = [], __$0 = 1; __$0 < arguments.length; ++__$0) args.push(arguments[__$0]); \n                test._(\"Input value is forwarded to the observer\")\n                .equals(value, token)\n                ._(\"Additional arguments are not forwarded\")\n                .equals(args.length, 0);\n            }\n\n        });\n    },\n\n    \"Return value\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var token = {};\n\n        new Observable(function(observer) {\n\n            test._(\"Returns the value returned from the observer\")\n            .equals(observer.error(), token);\n\n            test._(\"Throws the input when closed\")\n            .throws(function(_) { observer.error(token) }, token);\n\n        }).subscribe({\n            error: function() { return token }\n        });\n    },\n\n    \"Method lookup\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var observer,\n            error = new Error(),\n            observable = new Observable(function(x) { observer = x });\n\n        observable.subscribe({});\n        test._(\"If property does not exist, then error throws the input\")\n        .throws(function(_) { return observer.error(error); }, error);\n\n        observable.subscribe({ error: undefined });\n        test._(\"If property is undefined, then error throws the input\")\n        .throws(function(_) { return observer.error(error); }, error);\n\n        observable.subscribe({ error: null });\n        test._(\"If property is null, then error throws the input\")\n        .throws(function(_) { return observer.error(error); }, error);\n\n        observable.subscribe({ error: {} });\n        test._(\"If property is not a function, then an error is thrown\")\n        .throws(function(_) { return observer.error(); }, TypeError);\n\n        var actual = {};\n        observable.subscribe(actual);\n        actual.error = (function(_) { return 1; });\n        test._(\"Method is not accessed until error is called\")\n        .equals(observer.error(error), 1);\n\n        var called = 0;\n        observable.subscribe({\n            get error() {\n                called++;\n                return function() {};\n            }\n        });\n        observer.complete();\n        try { observer.error(error) }\n        catch (x) {}\n        test._(\"Method is not accessed when subscription is closed\")\n        .equals(called, 0);\n\n        called = 0;\n        observable.subscribe({\n            get error() {\n                called++;\n                return function() {};\n            }\n        });\n        observer.error();\n        test._(\"Property is only accessed once during a lookup\")\n        .equals(called, 1);\n\n        called = 0;\n        observable.subscribe({\n            next: function() { called++ },\n            get error() {\n                called++;\n                observer.next();\n                return function() {};\n            }\n        });\n        observer.error();\n        test._(\"When method lookup occurs, subscription is closed\")\n        .equals(called, 1);\n\n    },\n\n    \"Cleanup functions\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var called, observer;\n\n        var observable = new Observable(function(x) {\n            observer = x;\n            return function(_) { called++ };\n        });\n\n        called = 0;\n        observable.subscribe({});\n        try { observer.error() }\n        catch (x) {}\n        test._(\"Cleanup function is called when observer does not have an error method\")\n        .equals(called, 1);\n\n        called = 0;\n        observable.subscribe({ error: function() { return 1 } });\n        observer.error();\n        test._(\"Cleanup function is called when observer has an error method\")\n        .equals(called, 1);\n\n        called = 0;\n        observable.subscribe({ get error() { throw new Error() } });\n        try { observer.error() }\n        catch (x) {}\n        test._(\"Cleanup function is called when method lookup throws\")\n        .equals(called, 1);\n\n        called = 0;\n        observable.subscribe({ error: function() { throw new Error() } });\n        try { observer.error() }\n        catch (x) {}\n        test._(\"Cleanup function is called when method throws\")\n        .equals(called, 1);\n\n        var error = new Error(), caught = null;\n\n        new Observable(function(x) {\n            observer = x;\n            return function(_) { throw new Error() };\n        }).subscribe({ error: function() { throw error } });\n\n        try { observer.error() }\n        catch (x) { caught = x }\n\n        test._(\"If both error and the cleanup function throw, then the error \" +\n            \"from the error method is thrown\")\n        .assert(caught === error);\n\n    },\n\n};\n\n\n},\n11, function(module, exports) {\n\nvar testMethodProperty = __M(13).testMethodProperty;\n\nexports[\"default\"] = {\n\n    \"SubscriptionObserver.prototype has a complete method\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var observer;\n        new Observable(function(x) { observer = x }).subscribe({});\n\n        testMethodProperty(test, Object.getPrototypeOf(observer), \"complete\", {\n            configurable: true,\n            writable: true,\n            length: 1\n        });\n    },\n\n    \"Input value\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var token = {};\n\n        new Observable(function(observer) {\n\n            observer.complete(token, 1, 2);\n\n        }).subscribe({\n\n            complete: function(value) { for (var args = [], __$0 = 1; __$0 < arguments.length; ++__$0) args.push(arguments[__$0]); \n                test._(\"Input value is forwarded to the observer\")\n                .equals(value, token)\n                ._(\"Additional arguments are not forwarded\")\n                .equals(args.length, 0);\n            }\n\n        });\n    },\n\n    \"Return value\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var token = {};\n\n        new Observable(function(observer) {\n\n            test._(\"Returns the value returned from the observer\")\n            .equals(observer.complete(), token);\n\n            test._(\"Returns undefined when closed\")\n            .equals(observer.complete(), undefined);\n\n        }).subscribe({\n            complete: function() { return token }\n        });\n    },\n\n    \"Method lookup\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var observer,\n            observable = new Observable(function(x) { observer = x });\n\n        observable.subscribe({});\n        test._(\"If property does not exist, then complete returns undefined\")\n        .equals(observer.complete(), undefined);\n\n        observable.subscribe({ complete: undefined });\n        test._(\"If property is undefined, then complete returns undefined\")\n        .equals(observer.complete(), undefined);\n\n        observable.subscribe({ complete: null });\n        test._(\"If property is null, then complete returns undefined\")\n        .equals(observer.complete(), undefined);\n\n        observable.subscribe({ complete: {} });\n        test._(\"If property is not a function, then an error is thrown\")\n        .throws(function(_) { return observer.complete(); }, TypeError);\n\n        var actual = {};\n        observable.subscribe(actual);\n        actual.complete = (function(_) { return 1; });\n        test._(\"Method is not accessed until complete is called\")\n        .equals(observer.complete(), 1);\n\n        var called = 0;\n        observable.subscribe({\n            get complete() {\n                called++;\n                return function() {};\n            },\n            error: function() {},\n        });\n        observer.error(new Error());\n        observer.complete();\n        test._(\"Method is not accessed when subscription is closed\")\n        .equals(called, 0);\n\n        called = 0;\n        observable.subscribe({\n            get complete() {\n                called++;\n                return function() {};\n            }\n        });\n        observer.complete();\n        test._(\"Property is only accessed once during a lookup\")\n        .equals(called, 1);\n\n        called = 0;\n        observable.subscribe({\n            next: function() { called++ },\n            get complete() {\n                called++;\n                observer.next();\n                return function() { return 1 };\n            }\n        });\n        observer.complete();\n        test._(\"When method lookup occurs, subscription is closed\")\n        .equals(called, 1);\n\n    },\n\n    \"Cleanup functions\": function(test, __$0) { var __$1; var Observable = (__$1 = _esdown.objd(__$0), __$1.Observable); \n\n        var called, observer;\n\n        var observable = new Observable(function(x) {\n            observer = x;\n            return function(_) { called++ };\n        });\n\n        called = 0;\n        observable.subscribe({});\n        observer.complete();\n        test._(\"Cleanup function is called when observer does not have a complete method\")\n        .equals(called, 1);\n\n        called = 0;\n        observable.subscribe({ complete: function() { return 1 } });\n        observer.complete();\n        test._(\"Cleanup function is called when observer has a complete method\")\n        .equals(called, 1);\n\n        called = 0;\n        observable.subscribe({ get complete() { throw new Error() } });\n        try { observer.complete() }\n        catch (x) {}\n        test._(\"Cleanup function is called when method lookup throws\")\n        .equals(called, 1);\n\n        called = 0;\n        observable.subscribe({ complete: function() { throw new Error() } });\n        try { observer.complete() }\n        catch (x) {}\n        test._(\"Cleanup function is called when method throws\")\n        .equals(called, 1);\n\n        var error = new Error(), caught = null;\n\n        new Observable(function(x) {\n            observer = x;\n            return function(_) { throw new Error() };\n        }).subscribe({ complete: function() { throw error } });\n\n        try { observer.complete() }\n        catch (x) { caught = x }\n\n        test._(\"If both complete and the cleanup function throw, then the error \" +\n            \"from the complete method is thrown\")\n        .assert(caught === error);\n\n    },\n\n};\n\n\n},\n0, function(module, exports) {\n\nvar TestRunner = __M(1).TestRunner;\n\nvar constructor = __M(2)['default'];\nvar subscribe = __M(3)['default'];\nvar forEach = __M(4)['default'];\nvar observable = __M(5)['default'];\nvar species = __M(6)['default'];\nvar ofTests = __M(7)['default'];\nvar fromTests = __M(8)['default'];\n\nvar observerNext = __M(9)['default'];\nvar observerError = __M(10)['default'];\nvar observerComplete = __M(11)['default'];\n\n\nfunction runTests(C) {\n\n    return new TestRunner().inject({ Observable: C }).run({\n\n        \"Observable constructor\": constructor,\n\n        \"Observable.prototype.subscribe\": subscribe,\n        \"Observable.prototype.forEach\": forEach,\n        \"Observable.prototype[Symbol.observable]\": observable,\n\n        \"Observable.of\": ofTests,\n        \"Observable.from\": fromTests,\n        \"Observable[Symbol.species]\": species,\n\n        \"SubscriptionObserver.prototype.next\": observerNext,\n        \"SubscriptionObserver.prototype.error\": observerError,\n        \"SubscriptionObserver.prototype.complete\": observerComplete,\n\n    });\n}\n\nexports.runTests = runTests;\n\n\n}]);\n\n\n}, \"ObservableTests\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /home/vohhov/JS/~/es-observable-tests/es-observable-tests.js\n ** module id = 7\n ** module chunks = 0\n **/","/*=esdown=*/(function(fn, name) { if (typeof exports !== 'undefined') fn(exports, module); else if (typeof self !== 'undefined') fn(name === '*' ? self : (name ? self[name] = {} : {})); })(function(exports, module) { 'use strict'; // === Job Queueing ===\nvar enqueueJob = (function(_) {\n\n    // Node\n    if (typeof global !== \"undefined\" &&\n        typeof process !== \"undefined\" &&\n        process.nextTick) {\n\n        return global.setImmediate ?\n            function(fn) { return void global.setImmediate(fn); } :\n            function(fn) { return void process.nextTick(fn); };\n    }\n\n    // Browsers\n    return function(fn) { return void Promise.resolve().then(function(_) {\n        try { fn() }\n        catch (e) { setTimeout(function(_) { throw e }, 0) }\n    }); };\n\n})();\n\n// === Symbol Support ===\n\nfunction hasSymbol(name) {\n\n    return typeof Symbol === \"function\" && Boolean(Symbol[name]);\n}\n\nfunction getSymbol(name) {\n\n    return hasSymbol(name) ? Symbol[name] : \"@@\" + name;\n}\n\n// === Abstract Operations ===\n\nfunction getMethod(obj, key) {\n\n    var value = obj[key];\n\n    if (value == null)\n        return undefined;\n\n    if (typeof value !== \"function\")\n        throw new TypeError(value + \" is not a function\");\n\n    return value;\n}\n\nfunction getSpecies(ctor) {\n\n    var symbol = getSymbol(\"species\");\n    return symbol ? ctor[symbol] : ctor;\n}\n\nfunction addMethods(target, methods) {\n\n    Object.keys(methods).forEach(function(k) {\n\n        var desc = Object.getOwnPropertyDescriptor(methods, k);\n        desc.enumerable = false;\n        Object.defineProperty(target, k, desc);\n    });\n}\n\nfunction cleanupSubscription(subscription) {\n\n    // Assert:  observer._observer is undefined\n\n    var cleanup = subscription._cleanup;\n\n    if (!cleanup)\n        return;\n\n    // Drop the reference to the cleanup function so that we won't call it\n    // more than once\n    subscription._cleanup = undefined;\n\n    // Call the cleanup function\n    cleanup();\n}\n\nfunction subscriptionClosed(subscription) {\n\n    return subscription._observer === undefined;\n}\n\nfunction closeSubscription(subscription) {\n\n    if (subscriptionClosed(subscription))\n        return;\n\n    subscription._observer = undefined;\n    cleanupSubscription(subscription);\n}\n\nfunction cleanupFromSubscription(subscription) {\n    return function(_) { subscription.unsubscribe() };\n}\n\nfunction Subscription(observer, subscriber) {\n\n    // Assert: subscriber is callable\n\n    // The observer must be an object\n    if (Object(observer) !== observer)\n        throw new TypeError(\"Observer must be an object\");\n\n    this._cleanup = undefined;\n    this._observer = observer;\n\n    observer = new SubscriptionObserver(this);\n\n    try {\n\n        // Call the subscriber function\n        var cleanup$0 = subscriber.call(undefined, observer);\n\n        // The return value must be undefined, null, a subscription object, or a function\n        if (cleanup$0 != null) {\n\n            if (typeof cleanup$0.unsubscribe === \"function\")\n                cleanup$0 = cleanupFromSubscription(cleanup$0);\n            else if (typeof cleanup$0 !== \"function\")\n                throw new TypeError(cleanup$0 + \" is not a function\");\n\n            this._cleanup = cleanup$0;\n        }\n\n    } catch (e) {\n\n        // If an error occurs during startup, then attempt to send the error\n        // to the observer\n        observer.error(e);\n        return;\n    }\n\n    // If the stream is already finished, then perform cleanup\n    if (subscriptionClosed(this))\n        cleanupSubscription(this);\n}\n\naddMethods(Subscription.prototype = {}, {\n    unsubscribe: function() { closeSubscription(this) }\n});\n\nfunction SubscriptionObserver(subscription) {\n    this._subscription = subscription;\n}\n\naddMethods(SubscriptionObserver.prototype = {}, {\n\n    next: function(value) {\n\n        var subscription = this._subscription;\n\n        // If the stream if closed, then return undefined\n        if (subscriptionClosed(subscription))\n            return undefined;\n\n        var observer = subscription._observer;\n\n        try {\n\n            var m$0 = getMethod(observer, \"next\");\n\n            // If the observer doesn't support \"next\", then return undefined\n            if (!m$0)\n                return undefined;\n\n            // Send the next value to the sink\n            return m$0.call(observer, value);\n\n        } catch (e) {\n\n            // If the observer throws, then close the stream and rethrow the error\n            try { cleanupSubscription(subscription) }\n            finally { throw e }\n        }\n    },\n\n    error: function(value) {\n\n        var subscription = this._subscription;\n\n        // If the stream is closed, throw the error to the caller\n        if (subscriptionClosed(subscription))\n            throw value;\n\n        var observer = subscription._observer;\n        subscription._observer = undefined;\n\n        try {\n\n            var m$1 = getMethod(observer, \"error\");\n\n            // If the sink does not support \"error\", then throw the error to the caller\n            if (!m$1)\n                throw value;\n\n            value = m$1.call(observer, value);\n\n        } catch (e) {\n\n            try { cleanupSubscription(subscription) }\n            finally { throw e }\n        }\n\n        cleanupSubscription(subscription);\n        return value;\n    },\n\n    complete: function(value) {\n\n        var subscription = this._subscription;\n\n        // If the stream is closed, then return undefined\n        if (subscriptionClosed(subscription))\n            return undefined;\n\n        var observer = subscription._observer;\n        subscription._observer = undefined;\n\n        try {\n\n            var m$2 = getMethod(observer, \"complete\");\n\n            // If the sink does not support \"complete\", then return undefined\n            value = m$2 ? m$2.call(observer, value) : undefined;\n\n        } catch (e) {\n\n            try { cleanupSubscription(subscription) }\n            finally { throw e }\n        }\n\n        cleanupSubscription(subscription);\n        return value;\n    },\n\n});\n\nfunction Observable(subscriber) {\n\n    // The stream subscriber must be a function\n    if (typeof subscriber !== \"function\")\n        throw new TypeError(\"Observable initializer must be a function\");\n\n    this._subscriber = subscriber;\n}\n\naddMethods(Observable.prototype, {\n\n    subscribe: function(observer) {\n\n        return new Subscription(observer, this._subscriber);\n    },\n\n    forEach: function(fn) { var __this = this; \n\n        return new Promise(function(resolve, reject) {\n\n            if (typeof fn !== \"function\")\n                throw new TypeError(fn + \" is not a function\");\n\n            var subscription = __this.subscribe({\n\n                next: function(value) {\n\n                    try {\n\n                        return fn(value);\n\n                    } catch (e) {\n\n                        reject(e);\n                        subscription.unsubscribe();\n                    }\n                },\n\n                error: reject,\n                complete: resolve,\n            });\n        });\n    },\n\n    map: function(fn) { var __this = this; \n\n        if (typeof fn !== \"function\")\n            throw new TypeError(fn + \" is not a function\");\n\n        var C = getSpecies(this.constructor);\n\n        return new C(function(observer) { return __this.subscribe({\n\n            next: function(value) {\n\n                try { value = fn(value) }\n                catch (e) { return observer.error(e) }\n\n                return observer.next(value);\n            },\n\n            error: function(e) { return observer.error(e) },\n            complete: function() { return observer.complete() },\n        }); });\n    },\n\n    filter: function(fn) { var __this = this; \n\n        if (typeof fn !== \"function\")\n            throw new TypeError(fn + \" is not a function\");\n\n        var C = getSpecies(this.constructor);\n\n        return new C(function(observer) { return __this.subscribe({\n\n            next: function(value) {\n\n                try { if (!fn(value)) return undefined; }\n                catch (e) { return observer.error(e) }\n\n                return observer.next(value);\n            },\n\n            error: function(e) { return observer.error(e) },\n            complete: function() { return observer.complete() },\n        }); });\n    },\n\n    reduce: function(fn) { var __this = this; \n\n        if (typeof fn !== \"function\")\n            throw new TypeError(fn + \" is not a function\");\n\n        var C = getSpecies(this.constructor),\n            hasSeed = arguments.length > 1,\n            hasValue = false,\n            seed = arguments[1],\n            acc = seed;\n\n        return new C(function(observer) { return __this.subscribe({\n\n            next: function(value) {\n\n                var first = !hasValue;\n                hasValue = true;\n\n                if (!first || hasSeed) {\n\n                    try { acc = fn(acc, value) }\n                    catch (e) { return observer.error(e) }\n\n                } else {\n\n                    acc = value;\n                }\n            },\n\n            error: function(e) { return observer.error(e) },\n\n            complete: function() {\n\n                if (!hasValue && !hasSeed)\n                    observer.error(new TypeError(\"Cannot reduce an empty sequence\"));\n\n                observer.next(acc);\n                observer.complete();\n            },\n\n        }); });\n    },\n\n    flatMap: function(fn) { var __this = this; \n\n        if (typeof fn !== \"function\")\n            throw new TypeError(fn + \" is not a function\");\n\n        var C = getSpecies(this.constructor);\n\n        return new C(function(observer) {\n\n            var completed = false,\n                subscriptions = [];\n\n            // Subscribe to the outer Observable\n            var outer = __this.subscribe({\n\n                next: function(value) {\n\n                    if (fn) {\n\n                        try {\n\n                            value = fn(value);\n\n                        } catch (x) {\n\n                            observer.error(x);\n                            return;\n                        }\n                    }\n\n                    // Subscribe to the inner Observable\n                    var subscription = Observable.from(value).subscribe({\n\n                        next: function(value) { observer.next(value) },\n                        error: function(e) { observer.error(e) },\n                        complete: function() {\n\n                            var i = subscriptions.indexOf(subscription);\n\n                            if (i >= 0)\n                                subscriptions.splice(i, 1);\n\n                            closeIfDone();\n                        }\n                    });\n\n                    subscriptions.push(subscription);\n                },\n\n                error: function(e) { return observer.error(e) },\n\n                complete: function() {\n\n                    completed = true;\n                    closeIfDone();\n                }\n            });\n\n            function closeIfDone() {\n\n                if (completed && subscriptions.length === 0)\n                    observer.complete();\n            }\n\n            return function(_) {\n\n                subscriptions.forEach(function(s) { return s.unsubscribe(); });\n                outer.unsubscribe();\n            };\n        });\n    }\n\n});\n\nObject.defineProperty(Observable.prototype, getSymbol(\"observable\"), {\n    value: function() { return this },\n    writable: true,\n    configurable: true,\n});\n\naddMethods(Observable, {\n\n    from: function(x) {\n\n        var C = typeof this === \"function\" ? this : Observable;\n\n        if (x == null)\n            throw new TypeError(x + \" is not an object\");\n\n        var method = getMethod(x, getSymbol(\"observable\"));\n\n        if (method) {\n\n            var observable$0 = method.call(x);\n\n            if (Object(observable$0) !== observable$0)\n                throw new TypeError(observable$0 + \" is not an object\");\n\n            if (observable$0.constructor === C)\n                return observable$0;\n\n            return new C(function(observer) { return observable$0.subscribe(observer); });\n        }\n\n        return new C(function(observer) {\n\n            var done = false;\n\n            enqueueJob(function(_) {\n\n                if (done)\n                    return;\n\n                // Assume that the object is iterable.  If not, then the observer\n                // will receive an error.\n                try {\n\n                    if (hasSymbol(\"iterator\")) {\n\n                        for (var __$0 = (x)[Symbol.iterator](), __$1; __$1 = __$0.next(), !__$1.done;) { var item$0 = __$1.value; \n\n                            observer.next(item$0);\n\n                            if (done)\n                                return;\n                        }\n\n                    } else {\n\n                        if (!Array.isArray(x))\n                            throw new Error(x + \" is not an Array\");\n\n                        for (var i$0 = 0; i$0 < x.length; ++i$0) {\n\n                            observer.next(x[i$0]);\n\n                            if (done)\n                                return;\n                        }\n                    }\n\n                } catch (e) {\n\n                    // If observer.next throws an error, then the subscription will\n                    // be closed and the error method will simply rethrow\n                    observer.error(e);\n                    return;\n                }\n\n                observer.complete();\n            });\n\n            return function(_) { done = true };\n        });\n    },\n\n    of: function() { for (var items = [], __$0 = 0; __$0 < arguments.length; ++__$0) items.push(arguments[__$0]); \n\n        var C = typeof this === \"function\" ? this : Observable;\n\n        return new C(function(observer) {\n\n            var done = false;\n\n            enqueueJob(function(_) {\n\n                if (done)\n                    return;\n\n                for (var i$1 = 0; i$1 < items.length; ++i$1) {\n\n                    observer.next(items[i$1]);\n\n                    if (done)\n                        return;\n                }\n\n                observer.complete();\n            });\n\n            return function(_) { done = true };\n        });\n    },\n\n});\n\nObject.defineProperty(Observable, getSymbol(\"species\"), {\n    get: function() { return this },\n    configurable: true,\n});\n\nexports.Observable = Observable;\n\n\n}, \"*\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /home/vohhov/JS/~/zen-observable/zen-observable.js\n ** module id = 8\n ** module chunks = 0\n **/"],"sourceRoot":""}