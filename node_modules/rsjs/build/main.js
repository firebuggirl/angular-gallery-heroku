var RS =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

	"use strict";
	'use strict';
	
	module.exports = RS;
	
	/**
	 * @class Reactive Stream.
	 * @param {function} subscriber
	 */
	function RS(subscriber) {
	  if (typeof subscriber !== 'function') throw TypeError
	    ('Subscriber is not a function: ' + subscriber);
	
	  this._subscriber = subscriber;
	}
	
	/**
	 * Subscribe observer on stream.
	 * @memberof RS#
	 * @param {Object} observer
	 * @return {Subscription}
	 */
	function subscribe(observer) {
	  if (observer !== Object(observer)) throw TypeError
	    ('Observer is not an object: ' + observer);
	
	  var subscription = new Subscription, error, unsub,
	      control = new Control(observer, subscription);
	
	  try {
	    unsub = this._subscriber.call(undefined, control);
	  } catch (e) { error = e; }
	
	  if (unsub != null) {
	    if (typeof unsub.unsubscribe === 'function' ||
	        typeof unsub === 'function') {
	
	      if (subscription._unsub) {
	          subscription._unsub = unsub;
	      } else {
	          typeof unsub.unsubscribe === 'function' ?
	            unsub.unsubscribe() : unsub();
	      }
	
	    } else {
	      error = TypeError('Object has no method unsubscribe: ' + unsub);
	    }
	  }
	
	  if (error) control.error(error);
	
	  return subscription;
	}
	
	/**
	 * Call fn(item) for each stream item.
	 * @memberof RS#
	 * @param {function} fn
	 * @return {Promise} Resolve when stream complete.
	 */
	function forEach(fn) {
	  var stream = this;
	
	  function forEachResolver(resolver, reject) {
	    if (typeof fn !== 'function') throw TypeError
	      ('Not a function: ' + fn);
	    var observer = {
	      fn: fn,
	      next: _forEachNext,
	      error: reject,
	      complete: resolver
	    };
	    observer.subscription = stream.subscribe(observer);
	  }
	
	  return new Promise(forEachResolver);
	}
	
	/**
	 * Next action for method forEach.
	 * @param {*} value
	 */
	function _forEachNext(value) {
	  try { return this.fn.call(undefined, value); }
	  catch (e) {
	
	    try { this.error(e); } catch (e) {}
	
	    this.subscription.unsubscribe();
	  }
	}
	
	/**
	 * @class Control
	 * Control stream (SubscriptionObserver).
	 * @param {Object} observer
	 * @param {Subscription} subscription
	 */
	function Control(observer, subscription) {
	  this._observer = observer;
	  this._subscription = subscription;
	}
	
	/**
	 * Send next value to stream.
	 * @memberof Control#
	 * @param {*} value
	 */
	function next(value) {
	  if (!this._subscription._unsub) return;
	
	  var next = this._observer.next;
	
	  try {
	    if (next != null && typeof next !== 'function')
	      throw TypeError('Object has no method next: ' + this._observer);
	
	    return next ? this._observer.next(value) : undefined;
	
	  } catch (e) {
	    try { this._subscription.unsubscribe(); }
	    finally { throw e; }
	  }
	}
	
	/**
	 * Send error to stream.
	 * @memberof Control#
	 * @param {*} value
	 */
	function error(value) {
	  if (!this._subscription._unsub) throw value;
	
	  var error = this._observer.error, thrown;
	
	  try {
	    if (error != null && typeof error !== 'function')
	      throw TypeError('Object has no method error: ' + this._observer);
	
	    if (error == null) throw value;
	
	    return this._observer.error(value);
	
	  } catch (e) { thrown = true; throw e; }
	  finally {
	    try { this._subscription.unsubscribe(); }
	    catch (e) { if (!thrown) throw e; }
	  }
	}
	
	/**
	 * Send completion to stream.
	 * @memberof Control#
	 * @param {*} value
	 */
	function complete(value) {
	  if (!this._subscription._unsub) return;
	
	  var complete = this._observer.complete, thrown;
	
	  try {
	    if (complete != null && typeof complete !== 'function')
	      throw TypeError('Object has no method complete: ' + this._observer);
	
	    return complete ? this._observer.complete(value) : undefined;
	
	  } catch (e) { thrown = true; throw e; }
	  finally {
	    try { this._subscription.unsubscribe(); }
	    catch (e) { if (!thrown) throw e; }
	  }
	}
	
	/**
	 * @class Subscription
	 * Connects a pair of stream-listener.
	 */
	function Subscription() {
	  this._unsub = true;
	}
	
	/**
	 * Unsubscribe from stream.
	 * @memberof Subscription#
	 */
	function unsubscribe() {
	  var unsub = this._unsub;
	
	  if (!unsub) return;
	
	  try {
	    if (unsub !== true) {
	      typeof unsub === 'function' ?
	        unsub() : unsub.unsubscribe();
	    }
	  } finally {
	    this._unsub = undefined;
	  }
	}
	
	/**
	 * True, if already unsubscribed.
	 * @memberof Subscription#
	 * @return {boolean}
	 */
	function isUnsubscribed() {
	  return !this._unsub;
	}
	
	/**
	 * Define non-enumerable methods for prototype.
	 * @param {Object} target
	 * @param {Object} methods
	 */
	function defineMethods(target, methods) {
	  for (var key in methods) {
	    desc.value = methods[key];
	    defineProperty(target, key, desc);
	  }
	}
	
	function returnThis() { return this; }
	
	var symbol = {}, symDef = typeof Symbol === 'function',
	    desc = {configurable: true},
	    defineProperty = Object.defineProperty;
	
	['species', 'observable', 'iterator'].forEach(function(key) {
	  symbol[key] = (symDef && Symbol[key]) || '@@' + key;
	});
	
	
	desc.get = isUnsubscribed;
	defineProperty(Subscription.prototype = {}, 'isUnsubscribed', desc);
	
	desc.get = returnThis;
	defineProperty(RS, symbol.species, desc);
	
	desc.writable = delete desc.get;
	
	desc.value = returnThis;
	defineProperty(RS.prototype, symbol.observable, desc);
	
	defineMethods(RS.prototype, {
	  subscribe: subscribe,
	  forEach: forEach
	});
	
	defineMethods(Subscription.prototype, {
	  unsubscribe: unsubscribe
	});
	
	defineMethods(Control.prototype = {}, {
	  next: next,
	  error: error,
	  complete: complete
	});

/***/ }
/******/ ]);
//# sourceMappingURL=main.js.map